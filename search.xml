<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[什么是BFC?]]></title>
    <url>%2F2017%2F12%2F27%2Fbfc%2F</url>
    <content type="text"><![CDATA[前言对于BFC的概念以及应用场景一直都不是很明白，今天着重去了解了一下，做了以下总结。 BFC的定义在解释 BFC 是什么之前，需要先介绍 Box、Formatting Context的概念。 Box: CSS布局的基本单位 Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子：block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；inline-level box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；run-in box: css3 中才有， 这儿先不讲了。 Formatting context Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。CSS2.1 中只有 BFC 和 IFC, CSS3 中还增加了 GFC 和 FFC。BFC（Block Formatting Context）直译为“块级格式化范围”。是 W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用当涉及到可视化布局的时候，Block Formatting Context提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。这里有点类似一个BFC就是一个独立的行政单位的意思。也可以说BFC就是一个作用范围。可以把它理解成是一个独立的容器，并且这个容器的里box的布局，与这个容器外的毫不相干 怎样才能形成BFC float的值不能为none overflow的值不能为visible display的值为table-cell, table-caption, inline-block中的任何一个 position的值不为relative和static BFC的约束规则 内部的Box会在垂直方向上一个接一个的放置 垂直方向的距离有margin决定(属于同一个BFC的两个相邻Box的margin会发生重叠，与方向无关) 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此 BFC的区域不会与float的元素区域重叠 计算BFC的高度时，浮动子元素也参与计算 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然看到以上的几条约束，让我想起学习css时的几条规则 Block元素会扩展到与父元素同宽，所以block元素会垂直排列垂直方向上的两个相邻DIV的margin会重叠，而水平方向不会(此规则并不完全正确)浮动元素会尽量接近往左上方（或右上方）为父元素设置overflow：hidden或浮动父元素，则会包含浮动元素 BFC的作用1. 不和浮动元素重叠如果一个浮动元素后面跟着一个非浮动的元素，那么就会产生一个覆盖的现象，很多自适应的两栏布局就是这么做的。比如下图的效果，参考例子12345678910111213141516171819202122&lt;style&gt; body &#123; width: 300px; position: relative; &#125; .aside &#123; width: 100px; height: 150px; float: left; background: #f66; &#125; .main &#123; height: 200px; background: #fcc; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;aside&quot;&gt;&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;&lt;/body&gt; 案例分析:很明显，.aside和.mian重叠了。试分析一下，由于两个box都处在同一个BFC中，都是以BFC边界为起点，如果两个box本身都具备BFC的话，会按顺序一个一个排列布局，现在.main并不具备BFC，根据BFC布局规则第3条 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 虽然存在浮动的元素aslide，但main的左边依然会与包含块的左边相接触根据BFC布局规则第四条： BFC的区域不会与float box重叠 我们可以通过通过触发main生成BFC， 来实现自适应两栏布局123.main &#123; overflow: hidden;&#125; 当触发main生成BFC后，这个新的BFC不会与浮动的aside重叠。因此会根据包含块的宽度，和aside的宽度，自动变窄。效果如下： 2. 清除元素内部浮动案例代码:12345678910111213141516171819&lt;style&gt; .par &#123; border: 5px solid #fcc; width: 300px; &#125; .child &#123; border: 5px solid #f66; width:100px; height: 100px; float: left; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;par&quot;&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 根据BFC布局规则第六条： 计算BFC的高度时，浮动元素也参与计算 为达到清除内部浮动，我们可以触发par生成BFC，那么par在计算高度时，par内部的浮动元素child也会参与计算。123.par&#123; overflow:hidden&#125; 加入上面样式，即可解决问题，效果如下: 3. 防止垂直 margin 重叠1234567891011121314&lt;style&gt; p &#123; color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align:center; margin: 100px; &#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;Haha&lt;/p&gt; &lt;p&gt;Hehe&lt;/p&gt;&lt;/body&gt; 页面如下:两个p之间的距离为100px，发送了margin重叠。根据BFC布局规则第二条： Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 我们可以在p外面包裹一层容器，并触发该容器生成一个BFC。那么两个P便不属于同一个BFC，就不会发生margin重叠了。12345678910111213141516171819&lt;style&gt; .wrap &#123; overflow: hidden; &#125; p &#123; color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align:center; margin: 100px; &#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;Haha&lt;/p&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;p&gt;Hehe&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 效果如下:按照BFC的定义，只有同属于一个BFC时，两个元素才有可能发生垂直Margin的重叠，这个包括相邻元素，嵌套元素，只要他们之间没有阻挡(例如边框，非空内容，padding等)就会发生margin重叠。因此要解决margin重叠问题，只要让它们不在同一个BFC就行了，但是对于两个相邻元素来说，意义不大，没有必要给它们加个外壳，但是对于嵌套元素来说就很有必要了，只要把父元素设为BFC就可以了。这样子元素的margin就不会和父元素的margin发生重叠了。 部分内容来自BFC背后神奇的原理]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于博客的个性化设置]]></title>
    <url>%2F2017%2F12%2F26%2FblogSet%2F</url>
    <content type="text"><![CDATA[前言很多人都想拥有个人风格的博客，我也参考了很多小伙伴关于hexo搭建博客个性化设置的文章，我总结了以下比较实用的几点，希望对有需要的小伙伴能有所帮助我选用的是NexT:首先是这个主题的样式简洁大方，却又不失强大的功能。再者就是主题作者对此开源项目的维护较好，所以我选择了 NexT 主题。其中选择Scheme是Pisces，双栏 Scheme，小家碧玉似的清新，很清晰的结构，当然也可以根据个人喜好进行选择 1.设置头像编辑主题配置文件， 修改字段 avatar， 值设置成头像的链接地址。其中，头像的链接地址可以是： 地址 值 完整的互联网 URI http://example.com/avatar.png 站点内的地址 将头像放置主题目录下的 source/uploads/ （新建 uploads 目录若不存在）配置为：avatar: /uploads/avatar.png或者 放置在 source/images/ 目录下配置为：avatar: /images/avatar.png 2.优化主题siderbar的头像就是为主题siderbar头像添加圆形化旋转的效果。修改/themes/next/source/css/_common/components/sidebar/sidebar-author.styl 文件，我的整个 sidebar-author.styl 文件的代码如下，你可以直接复制这段代码去替换你这个文件中的所有代码。 有一个注意事项，就是你要保证你的头像，也就是 avatar.jpg 这个图片是正方形，不是的话你要将其修改成正方形，这样才能通过样式将其展现为很好看的正圆，否则会是一个椭圆形。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ -webkit-animation: play 2s ease-out 1s 1; -moz-animation: play 2s ease-out 1s 1; animation: play 2s ease-out 1s 1; /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125;.site-author-name &#123; margin: $site-author-name-margin; text-align: $site-author-name-align; color: $site-author-name-color; font-weight: $site-author-name-weight;&#125;.site-description &#123; margin-top: $site-description-margin-top; text-align: $site-description-align; font-size: $site-description-font-size; color: $site-description-color;&#125; 3.字体和颜色的设置在 \themes\next\source\css_variables\custom.styl 文件中添加以下代码12345678910111213141516// 标题，修改成你期望的字体族$font-family-headings = Georgia, sans// 修改成你期望的字体族$font-family-base = &quot;Microsoft YaHei&quot;, Verdana, sans-serif// 代码字体$code-font-family = &quot;Input Mono&quot;, &quot;PT Mono&quot;, Consolas, Monaco, Menlo, monospace// 正文字体的大小$font-size-base = 16px// 代码字体的大小$code-font-size = 14px// 代码块颜色$code-foreground = #dd0055// Background color for &lt;body&gt;$body-bg-color = #e7e5dc //theme mist use #fdfdfd// text-color$text-color = #353535s 4.为博客加上GitHub丝带如果是Next主题（其他主题也差不多），添加GitHub丝带：在themes\next\layout_layout.swig中加入相关代码，记得修改自己的链接。 相关代码你可以在GitHub官方网站GitHub Ribbons上进行选择。 5. 设置代码的高亮主题6. 如何设置「阅读全文」在首页显示一篇文章的部分内容，并提供一个链接跳转到全文页面是一个常见的需求。 NexT 提供三种方式来控制文章在首页的显示方式。 也就是说，在首页显示文章的摘录并显示 阅读全文 按钮，可以通过以下方法： 在文章中使用 手动进行截断，Hexo 提供的方式 推荐 在文章的 front-matter 中添加 description，并提供文章摘录 自动形成摘要，在 主题配置文件 中添加：123auto_excerpt: enable: true length: 150 默认截取的长度为 150 字符，可以根据需要自行设定 参考 HEXO+GitHub搭建博客 - 优化 NexT的主题配置]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS Grid 布局]]></title>
    <url>%2F2017%2F12%2F15%2FcssGrid%2F</url>
    <content type="text"><![CDATA[为什么CSS Grid很重要？ 因为 CSS Grid 布局是 Web 的第一个真正的布局系统。它的目的是将内容组织成行列的形式，最终使开发人员能高度控制我们眼前屏幕上页面的显示效果。这意味着我们终于可以摒弃多年的各种 hack 和 trick 了，CSS Grid 布局不仅仅可以使复杂的布局和精美的排版成为可能，而且还可以使其变的干净利落可维护CSS网格布局是浏览器Flexbox布局之后最重要的布局方式 专业术语 在整个网格中常用到的术语有：网格线（Grid lines）、水平或纵向网格轨道（Grid tracks）。网格轨道其实就相当于行（rows）和列（columns），而且两者之间有一个间距（Gutters）。在网格轨道相交的区域，就是单元格（Grid cells），相当于table中的单元格著作权归作者所有。 网格线(Grid lines)上图突出显示的红线就是第二列的网格线（line2）。 网格轨道(Grid track )网格轨道就是相邻两个网格线之间的空间，就好比表格中行或列。所在在网格中其分为grid column和grid row。每个网格轨道可以设置一个大小，用来控制宽度或高度。图中突出显示的就是行线line2和line3之间组成的网格轨道。 网络单元格(Grid cell)图中突出显示的单元格是由行线line2、line3和列表line2、line3组成的。 网格区域(Grid area)格区域是由任意四条网格线组成的空间，所以他可能包含一个或多个单元格。相当于表格中的合并单元格之后的区域。图中突出显示的网格区域是行线line1、line3和列线line2、line4之间的区域，其主要包括了四个网格单元格。 网格容器(Grid Containers)通过使用display属性给元素显式设置了属性值grid或inline-grid，此时这个元素将自动变成网格容器。这个类似于flexbox一样，将元素设置设置为display:flex，元素将自动变成弹性盒模型。 由于网格容器不是块容器，所以有部分属性在网格布局中将会失效： 多列布局模块中的所有column-*属性运用在网格容器上将失效 float和clear使用在网格项目（网格单元格Grid Cell）上将失效 vertical-align使用在网格单元格上将失效 ::first-line和::first-letter这样的伪元素不能应用在网格容器上 CSS 网格布局具体实例如下代码12345678&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;letter&quot;&gt; A &lt;/div&gt; &lt;div class=&quot;letter&quot;&gt; B &lt;/div&gt;&lt;/div&gt; 首先，我们使用 font-size 和 color 设置这些字母的字体和颜色，然后使用诸如 align-items 和 justify-content 之类的 flexbox 属性将其居中。CSS Grid 没有替换 flexbox 属性，尽可能保留了它们的功能。我们甚至可以将这些属性与 CSS Grid 结合。但是现在先让我们回到这个 demo：在上面这个例子中，一个大的 div 又包含着两个 div ，它们默认属性是 display: block。接下来我们用 Grid layout 设置父类元素：123.wrapper &#123; display: grid;&#125; 完整的html和css代码如下:12345678&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;letter&quot;&gt; A &lt;/div&gt; &lt;div class=&quot;letter&quot;&gt; B &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021body,html &#123; padding: 0; margin: 0;&#125;.wrapper &#123; display: grid;&#125;.letter &#123; background-color: #0069b3; display: flex; justify-content: center; align-items: center; padding: 20px; font-size: 70px; color: white; line-height: 1; font-family: &apos;hobeaux-rococeaux-background&apos;, Helvetica; font-weight: 200; cursor: pointer; transition: all .3s ease;&#125; 则显示结果如下：事实上，想让我们的 grid 起作用，首先需要给它设置一个确切的行数和列数。在这个例子中，我们可以让两个字母并排排列：123456.wrapper &#123; display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 1px; background-color: black;&#125; 效果如下：首先我们用 grid-template-columns 创建了一个两列的网格，如果你以前没见过这样的，那 1fr 可能看起来比较奇怪 ，但它是有效的 CSS 单元，可以将每一列列为我们网格的一小部分。在这个例子中，意味着让两列等宽。两列之间的黑线是 wrapper 勾勒的每个字母 div 的背景，因为我们将 grid-column-gap 设置为了 1px。通常，我们会设置更大的距离，尤其是对于两个相邻的文本框来说。但在本例中，1px 就足够了。如果我们再添加两个新字母会怎样呢？我们应该怎么改变布局？1234567891011121314&lt;div class=&apos;wrapper&apos;&gt; &lt;div class=&apos;letter&apos;&gt; A &lt;/div&gt; &lt;div class=&apos;letter&apos;&gt; B &lt;/div&gt; &lt;div class=&apos;letter&apos;&gt; C &lt;/div&gt; &lt;div class=&apos;letter&apos;&gt; D &lt;/div&gt;&lt;/div&gt; 加两个字母之后也没啥神奇的效果。加两个字母对网格没什么影响，为什么呢？因为我们已经将其设置成了两列，所以这两个字母的 div 直接被放在了它们下面，并且正好是 1fr宽：grid-column-gap 只用于列,要想实现A,C之间以及B,D之间也有1px的距离。需要设置grid-row-gap1234.wrapper &#123; grid-column-gap: 1px; grid-row-gap: 1px;&#125; 效果如下 响应式网格如何实现123456789101112.wrapper &#123; display: grid; grid-template-columns: 1fr 1fr; @media screen and (min-width: 500px) &#123; grid-template-columns: 1fr 1fr 1fr; &#125; @media screen and (min-width: 800px) &#123; grid-template-columns: 1fr 1fr 1fr 1fr; &#125;&#125; 分析下段代码12345.wrapper &#123; display: grid; grid-template-columns: 3fr 1fr 1fr; grid-template-rows: 1fr 3fr;&#125; 我们现在可以设置行高之间的关系。如果我们把前面的行高设成 1fr ，最后一个则设置为 3fr，这意味着第二行的行高是第一行的3倍： 实现一个基本的网格布局,总结一下这四个基本步骤： 创建一个容器，通过display:grid;声明这个容器是一个网格容器 同样在容器中设置grid-template-columns和grid-template-rows声明网格轨道(声明行和列) 在网格容器中添加子元素，创建网格项目(单元格) 使用grid-column和grid-row来指定网格项目（单元格）的列和行 参考文献 CSS Grid 布局入 门 什么是 CSS Grid]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的javaScript]]></title>
    <url>%2F2017%2F12%2F05%2FjavaScript%2F</url>
    <content type="text"><![CDATA[前言 最近在看你不知道的javaScript这本书，看书的过程中，有一个很明显的感觉就是自己懂得太少。javaScript既是一门充满吸引力，简单易用的语言，又是一门具有较多复杂微妙技术的语言。本着知其然知其所以然的精神，我对读完这本书做了一个简单的总结，不过很多东西要反复琢磨才能真正理解 1. 作用域是什么？ 作用域是一套规则，用于确定在何处以及如何查找变量(标识符)。如果查找的目的是对变量的赋值，那么就会使用LHS查询；如果目的是获取变量的值，就会使用就会使用RHS查询。赋值操作符会导致LHS查询,=操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。 像var = 2这样的声明会被分解两个独立的步骤 1.首先，var a在其作用域声明新变量，这是在最开始的阶段，也就是代码执行前进行 2.接着，a = 2会查询(LHS查询)变量a并对其赋值 LHS和RHS查询都会在当前执行作用域开始，如果有需要，就会向上级作用域继续查找目标标识符，这样每次上升一级作用域，最后抵达全局作用域，无论找到或没找到都将停止 什么是LHS和RHS?LHS和RHS的含义是赋值操作的左侧或右侧，但并不意味就是”=赋值操作符的左侧或右侧”LHS可以理解为赋值操作的目标是谁。RHS可以理解为谁是赋值操作的源头 2. 词法作用域词法作用域是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里决定的，因此词法分析器处理代码时会保持作用域不变12345678function foo(a)&#123; var b = a*2; function bar(c)&#123; console.log(a,b,c) &#125; bar(b*3)&#125;foo(2)//2,4,12 在上面的例子中有三个逐级嵌套的作用域 包含整个的全局作用域，其中有一个标识符:foo 包含foo所创建的作用域，其中有三个标识符:a,bar和b 包含bar所创建的作用域，其中只有一个标识符：c3. let let关键字可以变量绑定到所在的任意作用域中(通常是{..}的内部，换句话说，let为其声明的变量隐式地了所在的块作用域使用let进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不“存在”例如12console.log(bar);//ReferenceErrorlet bar = 2 ; let的for循环for循环头部的let不仅将i绑定到for循环中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值12345let j;for(j=0; j&lt;10;j++)&#123; let i = j;//每个迭代重新绑定 console.log(i)&#125; let声明附属于一个新的作用域而不是当前的函数作用域 4. constconst也可以创建块作用域变量，但是其值是固定的(常量12345678910var foo = true;if (foo)&#123; var a = 2; const b = 3; //包含在if中的块作用域常量 a = 3;//正常 b = 4;//错误&#125;console.log(a);//3console.log(b);//ReferenceError 函数是javaScript中最常见的作用域单元。但函数不是唯一的作用域单元，块作用域指的是变量和反函数不仅可以属于所在的作用域，也可予以属于某个代码块（通常指{..}内部）从ES6引入了let关键字(var关键字的表亲)，用来在任意代码块中声明变量，if(..){let a = 2}会声明一个劫持了if的{..}块的变量，并且将变量加到这个块中 5. 作用域闭包闭包是基于词法作用域书写代码时所产生的自然结果下面一段代码，清晰的展示了闭包123456789function foo()&#123; var a = 2; function bar()&#123; console.log(a); &#125; return bar;&#125;var baz = foo();baz();//2 这就是闭包的效果 函数bar()的词法作用域能访问到foo()的内部作用域，然后我们把bar()函数本身当做一个值类型进行传递，在这个例子中bar所引用的函数对象本身当作返回值bar()显然可以被正常运行。但它是在自己定义的词法作用域以外的地执行在foo()执行后，通常期待foo()的整个作用域后被销毁。而闭包的”神奇”之处就是阻止这件事情的发生。事实上内部作用域依然存在，bar()本身在使用。 拜bar()所声明的位置所赐，它拥有涵盖foo()内部作用域的闭包，使得该作用域能够一直存活，以供bar()在之后的任何时间进行引用bar()依然持有对该作用域的引用，而这个引用就叫做闭包123456function wait(message)&#123; setTimeout(function timer()&#123; console.log(message); &#125;,1000);&#125;wait(&quot;hello,closure!&quot;); 将一个内部函数(名为timer)传递给setTimeout(..).timer具有涵盖wait(..)作用域的闭包,因此还保有对变量message的引用wait(..)执行1000毫秒后，它的内部作用域并不会消失，timer函数依然保有wait(..)作用域的闭包这就是闭包。]]></content>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 this]]></title>
    <url>%2F2017%2F11%2F16%2Fthis%2F</url>
    <content type="text"><![CDATA[为什么要用thisthis 提供了一种更优雅的方式来隐式”传递”一个对象引用。可以将API设计的更加简洁并且易于复用。this既不是指向函数自身也不是指向函数的词法作用域。this实际上是函数在被调用时发生的绑定，它指向什么完全取决于函数在哪调用 对this的误解误区一 指向本身如下代码,this并不是我们所想的那样指向函数本身123456789101112131415161718function foo(num)&#123; console.log(&quot;foo:&quot;+num) //记录函数foo被调用的次数 this.count++;&#125;foo.count = 0;var i;for(i=0;i&lt;10;i++)&#123; if(i&gt;5)&#123; foo(i) &#125;&#125;//foo:6//foo:7//foo:8//foo:9//foo被调用了多少次？console.log(foo.count);//0 consolr.log语句产生了4条输出语句i，证明了foo(..)确实被调用了4次，但是foo.count仍然是0执行foo.count =0 时，的确向函数对象foo添加了一个属性count，但是函数内部代码this.count中的this并不是指向那个函数对象，所以属性名同名，但对象并不相同123456789101112131415161718function foo(num)&#123; console.log(&quot;foo:&quot;+num) //记录函数foo被调用的次数 foo.count++;&#125;foo.count = 0;var i;for(i=0;i&lt;10;i++)&#123; if(i&gt;5)&#123; foo(i) &#125;&#125;//foo:6//foo:7//foo:8//foo:9//foo被调用了多少次？console.log(foo.count);//4 这个方法回避了this的问题，并且完全依赖于foo的词法作用域另外一种方法强制this指向foo函数对象12345678910111213141516171819function foo(num)&#123; console.log(&quot;foo:&quot;+num) //记录函数foo被调用的次数 this.count++;&#125;foo.count = 0;var i;for(i=0;i&lt;10;i++)&#123; if(i&gt;5)&#123; //使用call(..)可以确保this指向函数对象foo本身 foo.call(foo,i) &#125;&#125;//foo:6//foo:7//foo:8//foo:9//foo被调用了多少次？console.log(foo.count);//4 这种方法接受了this，没有回避它 误区二 它的作用域this在任何情况下都不指向它的词法作用域如下段代码，试图跨越边界，使用this来隐式引用函数的词法作用域12345678function foo()&#123; var a = 2; this.bar();&#125;function bar ()&#123; console.log(this.bar)&#125;foo()//ReferenceError:a not a defined 这段代码试图使用this联通foo()和bar()的词法作用域，从而让bar()可以访问foo()作用域里的变量a。这是不可能实现的，使用this不可能在词法作用域中查到什么。当一个函数被调用时，会创建一个活动记录(或者说执行上下文)，这个记录会包含函数在哪里被调用，函数的调用方式，传入参数等信息，this就是这个记录的一个属性。会在函数的执行中用到this实际上是函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTTP｜GET 和 POST 区别]]></title>
    <url>%2F2017%2F11%2F03%2FHello%2F</url>
    <content type="text"><![CDATA[前言 关于get和post的区别，这是经典的面试题，以前了解的总是很表面，今天深入的了解了一下两者的真正区别大致可以分四点来说： 1. 关于传参数get通过URL或Cooike传参，而post将数据放入body中，这是因为Http协议的用法约定，并不是它们本身的区别 get和post是由HTTP协议定义的。在HTTP协议中，Method和Data（URL， Body， Header）是正交的两个概念，也就是说，使用哪个Method与应用层的数据如何传输是没有相互关系的。 HTTP没有要求，如果Method是POST数据就要放在BODY中。也没有要求，如果Method是GET，数据（参数）就一定要放在URL中而不能放在BODY中。 2. 关于提交的数据长度 get方式提交的数据有长度限制，而post的数据可以非常大，这是因为它们使用的操作系统和浏览器的不同引起的区别，也不是get和post本身的区别 3. 关于安全性post比get安全，因为在地址栏上不可见。 通过GET提交数据，用户名和密码将明文出现在URL上，因为登录页面有可能被浏览器缓存，其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击 4. 终极区别其实get和post的最大区别主要是get请求的幂等性，post请求不是 正因为它们有这样的区别，所以不应该且不能用get请求做数据的增删改这些有副作用的操作。因为get请求是幂等的，在网络不好的隧道中会尝试重试。如果用get请求增数据，会有重复操作的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作） 什么是幂等性?幂等性是指一次和多次请求某一资源应该具有同样的副作用。也就是说同一URL的多个请求应该返回同样的结果]]></content>
  </entry>
  <entry>
    <title><![CDATA[写给自己]]></title>
    <url>%2F2017%2F11%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[最近总会有一种恐慌感，关于自己，关于生活，关于工作。常常在思考自己想要什么，自己为之做出了什么努力。 关于自己 一直都觉着自己是一个乐观，正能量，目标很明确的人。可是行动力不强的我开始变得懒惰，开始慢慢的享受现在的安逸，有时候甚至故意欺骗自己说现在过的挺好，然后开始不去思考，得过且过。其实内心一直都知道自己要不断的学习，不断反思，才能不至于被淘汰。物竞天择，适者生存，无论什么时候，这都是社会的一个真实的状态 。 日子过的很快，我不愿静下心来去回忆一路走来自己的得与失，因为我知道自己是在逃避，害怕自己直面自己越来越差的状态。还记得刚毕业那会自己会有目标的学习，很有激情的工作，对生活充满美好，每一天都在憧憬美好的明天，每一天都是正能量满满，那才是认真生活的样子。 有一天，我发现和周围的朋友差距拉大时，我开始有了压力和危机感。我知道如果我再一直这样放任自己，我会变成自己最讨厌的那种不思进取的人。所以未来的日子还很长，我要做出改变 关于生活 自认为自己是一个热爱生活的人。喜欢周末的时候出门感受大自然的风光，自己是一个蛮爱玩的人。但是有段时间会迫切的希望日子过的快一点再快一点，我以为过的快一点糟心的事情会快点结束，其实并没有。不过还是要感谢过去好的或不好的日子，让我成长很多，也许这就是所谓的社会经验吧 一直喜欢用照片记录生活，可是自己并没有坚持很久。下了几次决定，要学习摄影，几次都是刚要开始就无疾而终了，接下来我要认真的去做这件事情，毕竟这还算生活我比较喜欢的一件事情。 用心去生活，感恩现在我拥有的一切，才会被生活说善待。努力生活成自己想要的样子，尽量让生活不留遗憾。 关于工作 对于自己的一个职业规划，自己一直以来都有一个大致的方向。但时间过的越久，恐慌感越逼近。当小伙伴们一个个变的越来越优秀，甚至超过自己很多时，我才突然意识到原来自己止步不前了太久。 去年自己就说要写自己的博客，记录下自己平常工作学习中碰到的一些问题，由于自己的拖延，一直都没有去执行，当时只完成了最基础的博客搭建。我知道这都是借口，最终的结果是一年以后我又重新开始，希望这次自己能说到做到 不够优秀，所以要比别人更努力，要更有自我反思的意识，方能在这个竞争激烈的社会有立足之地。所以不要给自己找太多借口，坚持下去，总会有意想不到的收获。 很喜欢一句话，自律的人才会有更多自由。所以为了过自己理想状态的生活，先要做一个自律的人]]></content>
  </entry>
</search>
