<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于博客的个性化设置]]></title>
    <url>%2Fblog%2F2017%2F12%2F26%2FblogSet%2F</url>
    <content type="text"><![CDATA[前言很多人都想拥有个人风格的博客，我也参考了很多小伙伴关于hexo搭建博客个性化设置的文章，我总结了以下比较实用的几点，希望对有需要的小伙伴能有所帮助我选用的是NexT:首先是这个主题的样式简洁大方，却又不失强大的功能。再者就是主题作者对此开源项目的维护较好，所以我选择了 NexT 主题。其中选择Scheme是Pisces，双栏 Scheme，小家碧玉似的清新，很清晰的结构，当然也可以根据个人喜好进行选择 1.设置头像编辑主题配置文件， 修改字段 avatar， 值设置成头像的链接地址。其中，头像的链接地址可以是： 地址 值 完整的互联网 URI http://example.com/avatar.png 站点内的地址 将头像放置主题目录下的 source/uploads/ （新建 uploads 目录若不存在）配置为：avatar: /uploads/avatar.png或者 放置在 source/images/ 目录下配置为：avatar: /images/avatar.png 2.优化主题siderbar的头像就是为主题siderbar头像添加圆形化旋转的效果。修改/themes/next/source/css/_common/components/sidebar/sidebar-author.styl 文件，我的整个 sidebar-author.styl 文件的代码如下，你可以直接复制这段代码去替换你这个文件中的所有代码。 有一个注意事项，就是你要保证你的头像，也就是 avatar.jpg 这个图片是正方形，不是的话你要将其修改成正方形，这样才能通过样式将其展现为很好看的正圆，否则会是一个椭圆形。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ -webkit-animation: play 2s ease-out 1s 1; -moz-animation: play 2s ease-out 1s 1; animation: play 2s ease-out 1s 1; /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125;.site-author-name &#123; margin: $site-author-name-margin; text-align: $site-author-name-align; color: $site-author-name-color; font-weight: $site-author-name-weight;&#125;.site-description &#123; margin-top: $site-description-margin-top; text-align: $site-description-align; font-size: $site-description-font-size; color: $site-description-color;&#125; 3.字体和颜色的设置在 \themes\next\source\css_variables\custom.styl 文件中添加以下代码12345678910111213141516// 标题，修改成你期望的字体族$font-family-headings = Georgia, sans// 修改成你期望的字体族$font-family-base = &quot;Microsoft YaHei&quot;, Verdana, sans-serif// 代码字体$code-font-family = &quot;Input Mono&quot;, &quot;PT Mono&quot;, Consolas, Monaco, Menlo, monospace// 正文字体的大小$font-size-base = 16px// 代码字体的大小$code-font-size = 14px// 代码块颜色$code-foreground = #dd0055// Background color for &lt;body&gt;$body-bg-color = #e7e5dc //theme mist use #fdfdfd// text-color$text-color = #353535s 4.为博客加上GitHub丝带如果是Next主题（其他主题也差不多），添加GitHub丝带：在themes\next\layout_layout.swig中加入相关代码，记得修改自己的链接。 相关代码你可以在GitHub官方网站GitHub Ribbons上进行选择。 5. 设置代码的高亮主题6. 如何设置「阅读全文」在首页显示一篇文章的部分内容，并提供一个链接跳转到全文页面是一个常见的需求。 NexT 提供三种方式来控制文章在首页的显示方式。 也就是说，在首页显示文章的摘录并显示 阅读全文 按钮，可以通过以下方法： 在文章中使用 手动进行截断，Hexo 提供的方式 推荐 在文章的 front-matter 中添加 description，并提供文章摘录 自动形成摘要，在 主题配置文件 中添加：123auto_excerpt: enable: true length: 150 默认截取的长度为 150 字符，可以根据需要自行设定]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS Grid 布局]]></title>
    <url>%2Fblog%2F2017%2F12%2F15%2FcssGrid%2F</url>
    <content type="text"><![CDATA[为什么CSS Grid很重要？ 因为 CSS Grid 布局是 Web 的第一个真正的布局系统。它的目的是将内容组织成行列的形式，最终使开发人员能高度控制我们眼前屏幕上页面的显示效果。这意味着我们终于可以摒弃多年的各种 hack 和 trick 了，CSS Grid 布局不仅仅可以使复杂的布局和精美的排版成为可能，而且还可以使其变的干净利落可维护 专业术语 在整个网格中常用到的术语有：网格线（Grid lines）、水平或纵向网格轨道（Grid tracks）。网格轨道其实就相当于行（rows）和列（columns），而且两者之间有一个间距（Gutters）。在网格轨道相交的区域，就是单元格（Grid cells），相当于table中的单元格著作权归作者所有。 网格线(Grid lines)实现一个基本的网格布局,总结一下这四个基本步骤： 创建一个容器，通过display:grid;声明这个容器是一个网格容器 同样在容器中设置grid-template-columns和grid-template-rows声明网格轨道(声明行和列) 在网格容器中添加子元素，创建网格项目(单元格) 使用grid-column和grid-row来指定网格项目（单元格）的列和行]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的javaScript]]></title>
    <url>%2Fblog%2F2017%2F12%2F05%2FjavaScript%2F</url>
    <content type="text"><![CDATA[前言 最近在看你不知道的javaScript这本书，看书的过程中，有一个很明显的感觉就是自己懂得太少。javaScript既是一门充满吸引力，简单易用的语言，又是一门具有较多复杂微妙技术的语言。本着知其然知其所以然的精神，我对读完这本书做了一个简单的总结，不过很多东西要反复琢磨才能真正理解 1. 作用域是什么？ 作用域是一套规则，用于确定在何处以及如何查找变量(标识符)。如果查找的目的是对变量的赋值，那么就会使用LHS查询；如果目的是获取变量的值，就会使用就会使用RHS查询。赋值操作符会导致LHS查询,=操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。 像var = 2这样的声明会被分解两个独立的步骤 1.首先，var a在其作用域声明新变量，这是在最开始的阶段，也就是代码执行前进行 2.接着，a = 2会查询(LHS查询)变量a并对其赋值 LHS和RHS查询都会在当前执行作用域开始，如果有需要，就会向上级作用域继续查找目标标识符，这样每次上升一级作用域，最后抵达全局作用域，无论找到或没找到都将停止 什么是LHS和RHS?LHS和RHS的含义是赋值操作的左侧或右侧，但并不意味就是”=赋值操作符的左侧或右侧”LHS可以理解为赋值操作的目标是谁。RHS可以理解为谁是赋值操作的源头 2. 词法作用域词法作用域是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里决定的，因此词法分析器处理代码时会保持作用域不变12345678function foo(a)&#123; var b = a*2; function bar(c)&#123; console.log(a,b,c) &#125; bar(b*3)&#125;foo(2)//2,4,12 在上面的例子中有三个逐级嵌套的作用域 包含整个的全局作用域，其中有一个标识符:foo 包含foo所创建的作用域，其中有三个标识符:a,bar和b 包含bar所创建的作用域，其中只有一个标识符：c3. let let关键字可以变量绑定到所在的任意作用域中(通常是{..}的内部，换句话说，let为其声明的变量隐式地了所在的块作用域使用let进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不“存在”例如12console.log(bar);//ReferenceErrorlet bar = 2 ; let的for循环for循环头部的let不仅将i绑定到for循环中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值12345let j;for(j=0; j&lt;10;j++)&#123; let i = j;//每个迭代重新绑定 console.log(i)&#125; let声明附属于一个新的作用域而不是当前的函数作用域 4. constconst也可以创建块作用域变量，但是其值是固定的(常量12345678910var foo = true;if (foo)&#123; var a = 2; const b = 3; //包含在if中的块作用域常量 a = 3;//正常 b = 4;//错误&#125;console.log(a);//3console.log(b);//ReferenceError 函数是javaScript中最常见的作用域单元。但函数不是唯一的作用域单元，块作用域指的是变量和反函数不仅可以属于所在的作用域，也可予以属于某个代码块（通常指{..}内部）从ES6引入了let关键字(var关键字的表亲)，用来在任意代码块中声明变量，if(..){let a = 2}会声明一个劫持了if的{..}块的变量，并且将变量加到这个块中 5. 作用域闭包闭包是基于词法作用域书写代码时所产生的自然结果下面一段代码，清晰的展示了闭包123456789function foo()&#123; var a = 2; function bar()&#123; console.log(a); &#125; return bar;&#125;var baz = foo();baz();//2 这就是闭包的效果 函数bar()的词法作用域能访问到foo()的内部作用域，然后我们把bar()函数本身当做一个值类型进行传递，在这个例子中bar所引用的函数对象本身当作返回值bar()显然可以被正常运行。但它是在自己定义的词法作用域以外的地执行在foo()执行后，通常期待foo()的整个作用域后被销毁。而闭包的”神奇”之处就是阻止这件事情的发生。事实上内部作用域依然存在，bar()本身在使用。 拜bar()所声明的位置所赐，它拥有涵盖foo()内部作用域的闭包，使得该作用域能够一直存活，以供bar()在之后的任何时间进行引用bar()依然持有对该作用域的引用，而这个引用就叫做闭包123456function wait(message)&#123; setTimeout(function timer()&#123; console.log(message); &#125;,1000);&#125;wait(&quot;hello,closure!&quot;); 将一个内部函数(名为timer)传递给setTimeout(..).timer具有涵盖wait(..)作用域的闭包,因此还保有对变量message的引用wait(..)执行1000毫秒后，它的内部作用域并不会消失，timer函数依然保有wait(..)作用域的闭包这就是闭包。]]></content>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 this]]></title>
    <url>%2Fblog%2F2017%2F11%2F16%2Fthis%2F</url>
    <content type="text"><![CDATA[为什么要用thisthis 提供了一种更优雅的方式来隐式”传递”一个对象引用。可以将API设计的更加简洁并且易于复用。this既不是指向函数自身也不是指向函数的词法作用域。this实际上是函数在被调用时发生的绑定，它指向什么完全取决于函数在哪调用 对this的误解误区一 指向本身如下代码,this并不是我们所想的那样指向函数本身123456789101112131415161718function foo(num)&#123; console.log(&quot;foo:&quot;+num) //记录函数foo被调用的次数 this.count++;&#125;foo.count = 0;var i;for(i=0;i&lt;10;i++)&#123; if(i&gt;5)&#123; foo(i) &#125;&#125;//foo:6//foo:7//foo:8//foo:9//foo被调用了多少次？console.log(foo.count);//0 consolr.log语句产生了4条输出语句i，证明了foo(..)确实被调用了4次，但是foo.count仍然是0执行foo.count =0 时，的确向函数对象foo添加了一个属性count，但是函数内部代码this.count中的this并不是指向那个函数对象，所以属性名同名，但对象并不相同123456789101112131415161718function foo(num)&#123; console.log(&quot;foo:&quot;+num) //记录函数foo被调用的次数 foo.count++;&#125;foo.count = 0;var i;for(i=0;i&lt;10;i++)&#123; if(i&gt;5)&#123; foo(i) &#125;&#125;//foo:6//foo:7//foo:8//foo:9//foo被调用了多少次？console.log(foo.count);//4 这个方法回避了this的问题，并且完全依赖于foo的词法作用域另外一种方法强制this指向foo函数对象12345678910111213141516171819function foo(num)&#123; console.log(&quot;foo:&quot;+num) //记录函数foo被调用的次数 this.count++;&#125;foo.count = 0;var i;for(i=0;i&lt;10;i++)&#123; if(i&gt;5)&#123; //使用call(..)可以确保this指向函数对象foo本身 foo.call(foo,i) &#125;&#125;//foo:6//foo:7//foo:8//foo:9//foo被调用了多少次？console.log(foo.count);//4 这种方法接受了this，没有回避它 误区二 它的作用域this在任何情况下都不指向它的词法作用域如下段代码，试图跨越边界，使用this来隐式引用函数的词法作用域12345678function foo()&#123; var a = 2; this.bar();&#125;function bar ()&#123; console.log(this.bar)&#125;foo()//ReferenceError:a not a defined 这段代码试图使用this联通foo()和bar()的词法作用域，从而让bar()可以访问foo()作用域里的变量a。这是不可能实现的，使用this不可能在词法作用域中查到什么。当一个函数被调用时，会创建一个活动记录(或者说执行上下文)，这个记录会包含函数在哪里被调用，函数的调用方式，传入参数等信息，this就是这个记录的一个属性。会在函数的执行中用到this实际上是函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTTP｜GET 和 POST 区别]]></title>
    <url>%2Fblog%2F2017%2F11%2F03%2FHello%2F</url>
    <content type="text"><![CDATA[前言 关于get和post的区别，这是经典的面试题，以前了解的总是很表面，今天深入的了解了一下两者的真正区别大致可以分四点来说： 1. 关于传参数get通过URL或Cooike传参，而post将数据放入body中，这是因为Http协议的用法约定，并不是它们本身的区别 get和post是由HTTP协议定义的。在HTTP协议中，Method和Data（URL， Body， Header）是正交的两个概念，也就是说，使用哪个Method与应用层的数据如何传输是没有相互关系的。 HTTP没有要求，如果Method是POST数据就要放在BODY中。也没有要求，如果Method是GET，数据（参数）就一定要放在URL中而不能放在BODY中。 2. 关于提交的数据长度 get方式提交的数据有长度限制，而post的数据可以非常大，这是因为它们使用的操作系统和浏览器的不同引起的区别，也不是get和post本身的区别 3. 关于安全性post比get安全，因为在地址栏上不可见。 通过GET提交数据，用户名和密码将明文出现在URL上，因为登录页面有可能被浏览器缓存，其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击 4. 终极区别其实get和post的最大区别主要是get请求的幂等性，post请求不是 正因为它们有这样的区别，所以不应该且不能用get请求做数据的增删改这些有副作用的操作。因为get请求是幂等的，在网络不好的隧道中会尝试重试。如果用get请求增数据，会有重复操作的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作） 什么是幂等性?幂等性是指一次和多次请求某一资源应该具有同样的副作用。也就是说同一URL的多个请求应该返回同样的结果]]></content>
  </entry>
  <entry>
    <title><![CDATA[写给自己]]></title>
    <url>%2Fblog%2F2017%2F11%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[最近总会有一种恐慌感，关于自己，关于生活，关于工作。常常在思考自己想要什么，自己为之做出了什么努力。 关于自己 一直都觉着自己是一个乐观，正能量，目标很明确的人。可是行动力不强的我开始变得懒惰，开始慢慢的享受现在的安逸，有时候甚至故意欺骗自己说现在过的挺好，然后开始不去思考，得过且过。其实内心一直都知道自己要不断的学习，不断反思，才能不至于被淘汰。物竞天择，适者生存，无论什么时候，这都是社会的一个真实的状态 。 日子过的很快，我不愿静下心来去回忆一路走来自己的得与失，因为我知道自己是在逃避，害怕自己直面自己越来越差的状态。还记得刚毕业那会自己会有目标的学习，很有激情的工作，对生活充满美好，每一天都在憧憬美好的明天，每一天都是正能量满满，那才是认真生活的样子。 有一天，我发现和周围的朋友差距拉大时，我开始有了压力和危机感。我知道如果我再一直这样放任自己，我会变成自己最讨厌的那种不思进取的人。所以未来的日子还很长，我要做出改变 关于生活 自认为自己是一个热爱生活的人。喜欢周末的时候出门感受大自然的风光，自己是一个蛮爱玩的人。但是有段时间会迫切的希望日子过的快一点再快一点，我以为过的快一点糟心的事情会快点结束，其实并没有。不过还是要感谢过去好的或不好的日子，让我成长很多，也许这就是所谓的社会经验吧 一直喜欢用照片记录生活，可是自己并没有坚持很久。下了几次决定，要学习摄影，几次都是刚要开始就无疾而终了，接下来我要认真的去做这件事情，毕竟这还算生活我比较喜欢的一件事情。 用心去生活，感恩现在我拥有的一切，才会被生活说善待。努力生活成自己想要的样子，尽量让生活不留遗憾。 关于工作 对于自己的一个职业规划，自己一直以来都有一个大致的方向。但时间过的越久，恐慌感越逼近。当小伙伴们一个个变的越来越优秀，甚至超过自己很多时，我才突然意识到原来自己止步不前了太久。 去年自己就说要写自己的博客，记录下自己平常工作学习中碰到的一些问题，由于自己的拖延，一直都没有去执行，当时只完成了最基础的博客搭建。我知道这都是借口，最终的结果是一年以后我又重新开始，希望这次自己能说到做到 不够优秀，所以要比别人更努力，要更有自我反思的意识，方能在这个竞争激烈的社会有立足之地。所以不要给自己找太多借口，坚持下去，总会有意想不到的收获。 很喜欢一句话，自律的人才会有更多自由。所以为了过自己理想状态的生活，先要做一个自律的人]]></content>
  </entry>
</search>
